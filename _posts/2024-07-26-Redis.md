# byLv

## Redis为什么快？

支持 10 W QPS。

Redis 经常出现的问题不是性能问题，而是网卡打满（网络跟不上）。

当主库压力大时不建议增加从库？一般不会在线上增加从库，都是在上线前定好架构，但是在线上主库压力大把从库摘掉是有可能得，因为本身压力就大，还要把数据同步到从库。

### 基于内存

### IO多路复用

客户端与服务端连接，每个连接（socket连接）都需要一个线程，不是每个连接时时刻刻都有数据传输，所以用一个线程监控多个 I/O 连接，这就叫 IO 多路复用。

### 单线程，减少上下文切换

单线程可以减少上下文切换，保证同一时间只能有一个请求的命令被 CPU 执行，同时也保证了命令的原子性（lua 脚本）；而多线程去抢夺CPU资源，会导致上下文切换，频繁加载/保存任务进度，开销大。

注：6.0 为什么又变多线程？真正去执行操作还是单线程，但是处理 IO 请求变成多线程，因为一个线程去处理 IO 请求经常会阻塞等待，

## 数据类型

https://xiaolincoding.com/redis/data_struct/command.html

### 常见

https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84

- String（字符串）

	- 内部实现

		- int

		- SDS

	- 应用场景

		- 缓存对象

			- JSON

			- Key分离

			  user:ID:属性 -> user:1:name
			  
		- 常规计数

		- 分布式锁

		- 共享 Session 信息

- List（列表）

	- 内部实现

		- Redis 3.2 前

			- 压缩列表

			- 双向链表

		- Redis 3.2 后

			- quicklist

	- 应用场景

		- 消息队列

- Hash（哈希）

	- 内部实现

		- Redis 7.0 前

			- 压缩列表

			- Hash 表

		- Redis 7.0 后

			- listpack

	- 应用场景

		- 缓存对象

		- 购物车

- Set（集合）

	- 内部实现

		- 整数集合

		- 哈希表

	- 应用场景

		- 点赞

		- 共同关注

		- 抽奖活动

- Zset（有序集合）

	- 内部实现

		- Redis 7.0 前

			- 压缩列表

			- 跳表

			  那层级只有 3 的跳表举例，头结点有 3 个指针，分别指向了不同层级的节点，然后各个层级的节点都是通过指针连接起来的；查询时先从高层级的找，然后逐步缩小层级范围，直到定位到元素。
			  
		- Redis 7.0 后

			- listpack

	- 应用场景

		- 排行榜

		- 电话、姓名排序

### 新增

https://xiaolincoding.com/redis/data_struct/command.html#bitmap

- BitMap（2.2 版新增）

	- 应用场景

		- 签到统计

		- 判断用户登陆态

		- 连续签到用户总数

- HyperLogLog（2.8 版新增）

	- 应用场景

		- 百万级网页 UV 计数

- GEO（3.2 版新增）

	- 应用场景

		- 滴滴叫车

- Stream（5.0 版新增）

	- 应用场景

		- 消息队列

## [锁](https://www.bilibili.com/video/BV1Rv41177Af?p=22&vd_source=146731dbc824138172a64a7faf714aab)

### [乐观锁](file:///P:/Java/Java/MyNotes/Java.xmind)

### 悲观锁

### [分布式锁](https://z.itpub.net/article/detail/F4B11BE73CB7F2DC1433FBFF8001F80B)

分布式环境下，只有一个线程能获取到锁。
MySQL唯一索引以及zookeeper也能做，为什么大都用 Redis？
快；
redission 框架出来早，功能较完善。
注：用 MySQL 唯一索引也可以实现。一般不建议这么做。
比 Redis 慢太多了；
MySQL 是关系型数据库，为业务而生。

- 加锁方式

	- 原生命令

	  set if not exist
	  
	  加锁方式：
	  setnx key value
	  key 不存在，设置 key 和 value，返回 1，key 存在，返回0；
	  用完之后，通过 delete 解锁。
	  
	  问题：
	  获取锁的服务挂掉了，锁会得不到释放，死锁。
	  
	  解决方案：
	  设置过期时间。
	  set key value nx ex seconds
	  nx：表示具备setnx特征；
	  ex：表示开启过期时间；
	  seconds：过期时间。
	  
	  问题：
	  保证了锁在时间过期后会释放锁，但是存在释放别人的锁（服务A获得了锁，因网络延迟、GC卡顿等导致锁过期，业务却还没结束，此时服务B拿到了锁准备执行，这时服务A恢复过来结束业务，就会释放B刚拿到的锁）。
	  
	  解决方案：设置客户端标识
	  加锁的时候设置一个客户端标识，同时也存入到 value，释放锁的时候先查看是不是自己的锁，比对客户端标识和 value ，是则释放。
	  但是查看锁和释放锁不是原子的，有可能查询时还是自己的锁，过一会锁过期了，别人获得了锁，那么删除时删的是别人的锁。
	  
	  升级方案：+ Rua 脚本
	  
	- [Redission框架](file:///P:/Redis/myNotes/Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%A3%E7%A0%81.md)

	  底层原理：基于 Redis 的 SETNX 命令和 Lua 脚本实现的。当一个线程尝试获取锁时，Redisson 会向 Redis 发送 SETNX 命令。当一个线程释放锁时，Redisson 会向 Redis 发送DEL命令，删除锁对应的 key。
	  
	  Redisson 还提供了可重入锁的实现方式，Redisson 会记录这个线程的 ID，并将锁的计数器加1，是基于 Hash 数据结构 key (value, n)，如：skucode (threadId, 1);
	  当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑；退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放。
	  
	  Redission 的 Watch Dog 机制：默认30秒过期，每过 10 秒看业务逻辑有没有执行完（怎么知道业务还在执行？ 定期发送续期命令到 Redis），还在执行则自动续约—— expire 30。
	  注：如果主动设置了过期时间，Watch Dog 不会生效。
	  
- Redis 分布式锁主从同步的时候会存在什么问题？

  如果主节点还没把数据同步到从节点，主节点宕机了，那么锁就会失效，从节点顶上来的时候（会变成主节点），别人是可以持有这把锁的。
  
  Redis 红锁（创建副本思想）：一半的节点加锁成功，才算成功，所以即使有一个节点宕机了，也不会加锁成功。
  
## 事务

如果命令有语法错误，则全部执行不了，相当于回滚；如果是执行命令报错、IO 异常或者宕机了，那就回滚不了。

参考资料：
尚硅谷：
https://www.bilibili.com/video/BV1Rv41177Af?p=21&vd_source=146731dbc824138172a64a7faf714aab

### MULTI

### EXEC

### DISCARD

### WATCH

## 过期删除策略

内存空间很宝贵，需要对过期的key进行删除，Redis默认使用定期抽查删除+惰性删除策略：这两种策略的配和使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。

### 定时删除策略

在设置 key 的过期时间时，同时创建一个定时事件，当时间到达，事件处理器自动执行 key 的删除操作。

- 优点

  对内存友好，因为它保证过期的 key 会被尽快删除，将内存释放。
  
- 缺点

  对 CPU 不友好，因为过期的 key 比较多的情况下，会占用相当一部分 CPU 时间，内存不紧张但 CPU 时间紧张的情况下，把CPU 时间用在删除和当前任务无关的 key 上，会对服务器的响应时间和吞吐量造成影响。
  
### 惰性删除策略

每次从数据库访问 key 时，都检测 key 是否过期，过期则删除。

- 优点

  对 CPU 友好，因为只有每次访问时才会检查 key 是否过期并决定是否删除。
  
  
- 缺点

  对内存不友好，因为如果一个 key 已经过期，而这个 key 仍保留在数据库中，那么这个 key 只要一直没有被访问，它所占用的内存就不会释放，会造成一定的内存空间浪费。
  
  
### 定期抽查删除策略

每隔一段时间随机从数据库中抽查一定数量的 key，删除过期的key。

- 优点

  减少了删除操作对 CPU 的影响，同时也减少了过期的 key 对内存的无效占用。
  
  
- 缺点

  内存清理方面没有定时删除效果好，CPU 使用时间没有惰性删除的少。
  不好把握执行此策略的频率和抽查量。执行的太频繁并且抽查的量多，就会变得和定时删除策略一样，对CPU不友好；执行的太少并且抽查的量少，那又会变得和惰性删除一样，过期的key占用的内存不能及时释放。
  
## 内存淘汰策略

内存空间有限，内存超过 Redis 设置的最大内存需要使用内存淘汰策略删除符合条件的 key，默认使用的是LRU（最近最少使用）算法。

### 不进行数据淘汰的策略

- noeviction
（Redis3.0之后默认的内存淘汰策略）

  运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错，通知禁止写入，但是如果没有数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。
  
### 进行数据淘汰的策略

- 在设置了过期时间的数据中进行淘汰

	- volatile-random

	  随机淘汰设置了过期时间的键值。
	  
	- volatile-ttl

	  time to live：优先淘汰更早过期的键值。
	  
	- volatile-lru
（Redis3.0之前默认的内存淘汰策略）

	  最近最少使用（least recently used）：淘汰所有设置了过期时间的键值中，长时间未使用的键值；
	  
	- volatile-lfu
（Redis 4.0后新增的内存淘汰策略）

	  最不常用（least frequently used）：淘汰所有设置了过期时间的键值中最少使用的键值；
	  
- 在所有数据范围内进行淘汰

	- allkeys-random

	  随机淘汰任意键值。
	  
	- allkeys-lru

	  淘汰所有键值中长时间未使用的键值
	  
	- allkeys-lfu
（Redis 4.0后新增的内存淘汰策略）

	  淘汰所有键值中最少使用的键值
	  
## 持久化

Redis 4.0 之后提出 AOF 和 RDB 混合持久化，需要手动开启


### AOF 日志

增量备份：Redis 每执行一条写命令，命令都以追加的方式写入到一个文件里；重启 Redis 时，读取这个文件里的命令，然后执行它。

- 优点

  AOF 日志是秒级的记录命令，丢失的数据相对较少。
  
- 缺点

  如果 AOF 文件很大，命令逐一的执行来恢复数据，这种方式很慢。
  
- Redis 先执行写操作后，再将该命令记录到 AOF 日志的优点与缺点？

	- 优点

		- 避免额外的检查开销

		  先将写命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，将错误的命令记录到 AOF 日志里后，不进行命令语法检查的话，Redis 在使用日志恢复数据时，就会出错。
		  而如果先执行写命令再记录到日志的话，只有该命令执行成功，才会把命令记录到 AOF 日志里，这样就不用额外的检查开销，保证 AOF 日志里的命令都是正确且可执行的。
		  
		- 不会阻塞当前写命令的执行

		  因为只有写命令执行成功后，才会把命令记录到 AOF 日志里。
		  
	- 缺点

		- 有数据丢失的风险

		  执行写命令和记录日志是两个过程，如果 Redis 没来得及将命令写入到硬盘时，服务器宕机了，数据就会有丢失的风险。
		  
		- 可能会给下一个命令带来阻塞风险

		  不会阻塞当前写命令的执行，但可能会给下一个命令带来阻塞风险。
		  
- 执行策略

	- Always

	  每次执行完写命令后，把命令写到 AOF 日志。
	  
	- Everysec

	  每次执行完写命令后，先把命令写到 AOF 缓冲区，然后每隔一秒把缓冲区里的数据写到AOF文件。
	  
	- No

	  不由 Redis 控制写回硬盘的时机，由操作系统控制，每次执行完写命令后，先把命令写到 AOF 缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。
	  
- AOF重写

  AOF 重写机制：重写时，读取 Redis 中的所有键值对，将每一个键值对用一条命令记录到新的 AOF 文件，全部记录完后，将新的 AOF 文件替换掉现有的 AOF 文件。
  
  注：当 AOF 文件的大小超过设定的阈值后，Redis 就会启用 AOF 重写机制压缩 AOF 文件。
  
	- 用后台子进程完成重写 AOF 的两个好处

	  子进程 AOF 重写期间，主进程可以继续处理请求命令，可以避免阻塞主进程；
	  子进程共享主进程的数据，节约了物理内存资源：
	  创建子进程时，操作系统会复制一份主进程的页表给子进程，页表记录着虚拟地址和物理地址的映射关系，虽然两者的虚拟空间不同，但其对应的物理空间是同一个，而不会复制物理内存，这样一来，子进程就拥有父进程的物理内存数据了。
	  注：当父进程或者子进程在向这个内存发起写操作时，会触发写时复制（复制物理内存）（Copy-On-Write）。
	  
	- 为什么使用子进程而不是子线程？

	  因为使用线程，多线程之间会共享内存，在修改共享内存数据时，需要加锁来保证数据的安全，从而降低性能。而使用子进程，创建子进程时，子进程以只读的方式共享父进程的内存数据，而当父子进程任意一方修改了共享的内存数据，就会触发写时复制，父子进程拥有独立的数据副本，就不用通过加锁来保证数据安全。
	  
	- 重写 AOF 日志期间主进程修改了已经存在的key-value，怎么解决子进程与主进程造成的内存数据不一致？

	  Redis 设置了一个 AOF 重写缓冲区在创建子进程之后使用。
	  重写 AOF 期间，Redis 执行完一个写命令之后，它会同时将这个写命令写入到 AOF 缓冲区和 AOF 重写缓冲区，当子进程完成 AOF 重写工作会异步向主进程发送一条信号，主进程收到该信号后，将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件后，让数据保持一致。
	  
### RDB 日志

全量备份：RDB 快照就是记录某一个瞬间的内存数据，服务器启动时自动加载 RDB 文件。

- 优点

  RDB 恢复数据的比 AOF 高些，只要把 RDB 文件直接读入内存就可以，不需要像 AOF 那样需要额外的逐一执行命令恢复数据。
  
- 缺点

  丢失的数据比 AOF 持久化更多，因为执行快照是一个比较重的操作，执行的频率不能太频繁，所以丢失的数据会更多，如果执行太频繁，会降低 Redis 性能。
  
- 生成 RDB 文件的两个命令

	- save

	  在主线程生成 RDB 文件，和执行命令在同一个线程，如果写入 RDB 文件时间太长，会阻塞主线程。
	  
	- bgsave

	  创建一个子进程来生成 RDB 文件，避免了主线程的阻塞。
	  
- 执行策略

  满足下面任意一个条件，就会执行 bgsave：
  900 秒之内，对数据库进行了至少 1 次修改；
  300 秒之内，对数据库进行了至少 10 次修改；
  60 秒之内，对数据库进行了至少 10000 次修改。
  
- 子进程构建 RDB 文件时，主进程怎么做到还可以修改数据的？

  关键的技术就在于写时复制技术。
  注：这期间，主进程修改的数据，是没办法写入 RDB 文件的，只能交由下一次的 bgsave 快照，如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。
  
### AOF 和 RDB混合持久化

开启混合持久化后，在 AOF 重写日志时，重写子进程先把与主进程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主进程处理的命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。
也就是说，使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。


### Redis主从同步

先同步RDB，再同步AOF：

主服务器可以进行读写，当发生写操作时，自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来的写操作，并执行这条命令。

- 主从同步流程

	- 1.建立连接、协商同步

	  从服务器执行了 replicaof 命令后，就会变成从服务器，并会给主服务器发送 psync 命令，表示要同步数据，主服务器收到 psync 命令后，会用 FULLRESYNC（全量复制） 命令作为响应。
	  
	- 2.主服务器同步数据给从服务器

	  主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器，从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件，完成 RDB 的载入后，会回复一个确认消息给主服务器。期间的写操作命令，会写入到 replication buffer 缓冲区里，这期间主要包括下面三个间隙：
	  主服务器生成 RDB 文件期间；
	  主服务器发送 RDB 文件给从服务器期间；
	  从服务器加载 RDB 文件期间；
	  
	- 3.主服务器将 replication buffer 缓冲区里的写命令发送给从服务器

	  接着，主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行命令，这时主从服务器的数据就一致了，完成了主从服务器的第一次同步。完成第一次同步后，双方之间就会维护一个 TCP 连接。
	  
- 分摊主服务器的压力

  如果主服务器的从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来两个问题：
  主服务器就会忙于使用创建子进程，如果主服务器的数据非多，在创建子进程时会阻塞主线程的，使得 Redis 无法正常处理请求；
  传输 RDB 文件会占用主服务器的网络带宽，会影响主服务器响应命令请求。
  如何解决？从服务器可以有自己的从服务器，它不仅可以接收主服务器的同步数据，也可以作为主服务器的形式将数据同步给从服务器。
  
- 过期key如何处理?

  主节点处理了一个key或者淘汰了一个key，主节点会模拟一条del命令发送给从节点，从节点收到该命令后，就会删除key。
  
- 如何应对主从数据不一致？

  为什么会出现主从数据不一致？主节点收到新的写命令后，在本地执行完命令后，会发送给从节点并立即向客户端返回结果，并不会等到从节点执行完命令，如果从节点还没有执行主节点同步过来的命令，主从节点间的数据就不一致了。
  如何解决？
  避免主从节点在不同的机房，尽量保证主从节点间的网络状况良好。
  todo。
  
## [缓存高并发场景](https://xiaolincoding.com/redis/cluster/cache_problem.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F)

### 缓存雪崩

当大量缓存同时过期或者 Redis 故障宕机时，大量的用户请求都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库压力骤增，严重的话会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。

- 大量数据同时过期

	- 均匀设置过期时间

	  对缓存设置过期时间时，给这些数据的过期时间加上一个随机数，这样就保证了数据不会在同一时间过期，避免将大量的数据设置相同的过期时间。
	  
	- 加锁

	  当发现访问的数据不在 Redis 里，就加个互斥锁（最好设置超时时间，防止意外不释放锁），只允许同一时间只有一个请求来构建缓存。
	  
	- 后台更新缓存

	  缓存不设置过期时间，更新缓存的工作交由后台线程定时更新。
	  
	  缓存不设置过期时间，并不意味着一直在内存里，系统内存紧张的时，有些缓存也会被“淘汰”，再后台更新之前，造成数据丢失，有两种方式解决这种问题：
	  后台线程以毫秒级别的频率检测缓存是否有效，失效了就马上从数据库读取数据到缓存。
	  业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存，后台线程收到消息后，读取数据库数据并加载到缓存。这种方式相比第一种方式及时，用户体验也好。
	  后台更新缓存的机制刚好也适合缓存预热（用户访问前构建缓存）。
	  
- Redis 故障宕机

	- 服务熔断或请求限流机制

	  启动服务熔断机制，暂停业务对缓存的访问，直接返回错误，保证数据库系统正常运行。
	  但是暂停了业务访问缓存，全部业务都无法正常工作，为了减少对业务的影响，我们可以启用请求限流机制，只将少部分请求发送到数据库进行处理，其余的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。
	  
	- 构建 Redis 高可靠集群

	  以主从节点的方式构建 Redis 高可靠集群，如果 Redis 的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务。
	  
### 缓存击穿

缓存雪崩的一种特殊情况，如果缓存中的某个热点数据过期了，此时大量请求访问来访问，就无法从缓存中读取，便直接访问数据库。
可以采用缓存雪崩里的互斥锁和后台更新缓存的方式。

### 缓存穿透

请求访问的数据既不在缓存中，也不在数据库中，就没办法构建缓存，大量这样的请求每次都打到数据库里。

注：造成这种问题一般是下面两种情况：
业务误操作，缓存中的数据和数据库中的数据都被误删了。
黑客恶意攻击，故意大量访问某些读取不到数据的业务。

- 黑客攻击

	- 非法请求的限制

	  在 API 入口处校验请求参数（是否含有非法值、请求字段是否存在），如果是恶意请求就直接返回错误。
	  
	- 缓存空值或者默认值

	  发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置空值或者默认值，返回给后续请求。
	  
	- 使用布隆过滤器

	  数据写入数据库时，使用布隆过滤器做个标记，缓存失效后，可以通过布隆过滤器判断数据是否存在，不存在则不访问数据库。
	  
- 业务误操作

## 数据库与缓存一致（双写一致性）

数据库和缓存的数据没有办法完全保证一致性。

读请求：
如果从缓存读取到了数据，则直接返回数据；
如果从缓存没读取到了数据，则从数据库中读取，然后将数据写入到缓存，并且返回给用户。
参考资料：
IT 老哥：
https://www.bilibili.com/video/BV1dU4y1f7Pa/?vd_source=146731dbc824138172a64a7faf714aab
小林 coding：
https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7

### IT 老哥

- MySQL 单机

	- 先更新缓存，再更新数据库

	  如果更新缓存成功了，数据库更新失败了，这时候数据库回滚，缓存是回滚不了的，这就造成数据不一致了；而且缓存的数据它是经过一系列的计算再存到里面的，这时就白算了，所以这是一个很笨的方法；而且存储以数据库为中心，所以要先更新数据库。
	  
	- 先更新数据库，再更新缓存

	  请求 A、B 同时去更新数据，可能出现下面顺序：
	  请求 A 更新数据库的数据（相对于 B 是旧值）；
	  请求 B 更新数据库的数据（相对于 A 是新值）；
	  请求 B 把新值更新到缓存；
	  请求 A 把旧值更新到缓存。
	  此时，数据库中的数据是新值，而缓存中的数据却是旧值，出现了数据不一致的现象。
	  
	- 先删除缓存，再更新数据库

	  请求 A 更新数据、B 读取数据，可能出现下面顺序：
	  请求 A 删除缓存；
	  请求 B 没读到缓存的数据，读取数据库的数据（相对于 A 是旧值）；
	  请求 B 更新旧值到缓存；
	  请求 A 更新数据库的数据（相对于 B 是新值）。
	  此时，数据库中的数据是新值，而缓存中的数据却是旧值，出现了数据不一致的现象。
	  
	- 先更新数据库，再删除缓存

	  请求 A 读取数据、B 更新数据，可能出现下面顺序：
	  请求 A 没读到缓存的数据，读取数据库的数据（相对于 B 是旧值）；
	  请求 B 更新数据库的数据（相对于 A 是新值）；
	  请求 B 删除缓存；
	  请求 A 更新旧值到缓存。
	  此时，数据库中的数据是新值，而缓存中的数据却是旧值，出现了数据不一致的现象，实际中这个问题出现的概率并不高，因为查询数据库要比更新数据库（涉及到锁）快，所以正常情况第 4 也会快于第 3；为了保证万无一失，给缓存加上过期时间，就算在这期间缓存不一致，有过期时间来兜底，也能达到最终一致；或者延迟删除，更新完数据库后睡眠一会再删除，由于休眠时间取决于读请求 从数据库读取数据 + 写入缓存 的时间，很难评估出来，所以这个方案也只是尽可能的保证一致性而已，极端情况下还是会出现缓存不一致。
	  
- MySQL 读写分离（主从架构）

  请求 A 更新数据、B 读取数据，可能出现下面顺序：
  请求 A 去主库更新数据，然后删除缓存，同时从库订阅了主库的 binlog 进行数据同步；
  请求 B 没读到缓存的数据去从库读取数据，由于网络原因，从库没有及时同步主库的数据，读取到的是旧值，此时请求 B 把旧值更新到缓存；
  过了一会，数据同步到了从库，此时数据库和缓存不一致。
  解决方案：
  请求去主库更新数据，同时从库订阅了主库的 binlog 进行数据同步，以及单独起一个服务使用 Canal 去订阅主库 binlog，通过它把最新的数据更新到缓存；如果有新的请求来读取数据，就会从缓存里面读取到最新数据，即使从库暂时没有同步到最新数据，也不会出现没读到缓存的数据去从库读取数据。
  注：
  更新 Redis 失败怎么办？比如网络问题失败了，我们可以重试，但是 Redis 挂了一直重试失败怎么办？那我们可以引入消息队列，如果更新失败，就把数据按顺序放入到里面，消费的时候也是单线程按顺序消费，Redis 重启后重新把数据更新到里面，消费不成功也可以重试。
  如果对数据一致性要求特别高，就不去从库查了，则去主库查。
  Canal 原理：MySQL 处理完请求，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供缓存（下游程序订阅）使用。
  
### 小林 coding

笔记摒弃了

- 双写请求不一致

  在 写 + 写 请求并发下造成的双写不一致
  
	- 先更新数据库，再更新缓存

	  请求 A、B 同时去更新数据，可能出现下面顺序：
	  请求 A 更新数据库的数据，相对于 B 是旧值
	  请求 B 更新数据库的数据，相对于 A 是新值
	  请求 B 把新值更新到缓存
	  请求 A 把旧值更新到缓存
	  此时，数据库中的数据是新值，而缓存中的数据却是旧值，出现了数据不一致的现象。
	  
		- 分布式锁

		- 缓存设置较短的过期时间

	- 先更新缓存，再更新数据库

	  请求 A、B 同时去更新数据，可能出现下面顺序：
	  请求 A 更新缓存的数据，相对于 B 是旧值
	  请求 B 更新缓存的数据，相对于 A 是新值
	  请求 B 更新新值到数据库
	  请求 A 更新旧值到数据库
	  此时，数据库中的数据是旧值，而缓存中的数据却是新值，出现了数据不一致的现象。
	  
- 读写请求不一致

  在 读 + 写 请求并发下造成的读写不一致
  
	- 先更新数据库，再删除缓存

	  请求 A 读取数据、B 更新数据，可能出现下面顺序：
	  请求 A 没读到缓存的数据，读取数据库的数据，相对于 B 是旧值
	  请求 B 更新数据库的数据，相对于 A 是新值
	  请求 B 删除缓存
	  请求 A 更新旧值到缓存
	  此时，数据库中的数据是新值，而缓存中的数据却是旧值，出现了数据不一致的现象，实际中这个问题出现的概率并不高，因为写缓存要比写数据库快，为了保证万无一失，给缓存加上过期时间，就算在这期间缓存不一致，有过期时间来兜底，也能达到最终一致。
	  
		- 消息队列重试机制

		- 订阅 MySQL binlog，再删除缓存

		  使用 Canal：MySQL 处理完请求，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供缓存（下游程序订阅）使用。
		  
	- 先删除缓存，再更新数据库

	  请求 A 更新数据、B 读取数据，可能出现下面顺序：
	  请求 A 删除缓存
	  请求 B 没读到缓存的数据，读取数据库的数据，相对于 A 是旧值
	  请求 B 更新旧值到缓存，
	  请求 A 更新数据库的数据，相对于 B 是新值
	  此时，数据库中的数据是新值，而缓存中的数据却是旧值，出现了数据不一致的现象。
	  
		- 延迟双删

		  先删除缓存，然后在更新完数据后，休眠一段时间，再删除缓存。由于休眠时间取决于读请求 从数据库读取数据 + 写入缓存 的时间，很难评估出来，所以这个方案也只是尽可能的保证一致性而已，极端情况下还是会出现缓存不一致。
		  
## 布隆过滤器

布隆过滤器由"初始值都为 0 的位图数组"和" N 个哈希函数"两部分组成。
标记过程：
使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；
用位图数组的长度分别对 N 个哈希值取模，得到对应在位图数组的位置。
在位图数组的对应位置的值设置为 1；
当查询数据是否存在数据库时，只需看数据经哈希运算在布隆过滤器位图数组上的位置的值是否全为 1，只要有一个为 0，就认为数据不在数据库中。

注：布隆过滤器存在哈希冲突，不在的数据也可能存在误判，查询到数据存在，数据库中不一定存在，但是查询到数据不存在，数据库中就一定不存在。


