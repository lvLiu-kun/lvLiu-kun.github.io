# 智能货柜

这个项目做了多少个月?从搭建到上线用了三四个月，但是我们后面一直在优化，比如后面加了个对账功能。
开发人员：
5 个人左右，2 个后端，1 个小程序，1 个前端，1 个运维。
10 个人左右，3个后端，1 个前端，1 个小程序前端，一个ui，一个测试。

为什么离职？这是我的一个学长接的私活，一家小公司，我能参与这个项目主要是因为我跟他比较熟，项目差不多起来了，留几个人维护就行了，公司业务没拓展了，我就走了。

## 表

### 设备表

### 账户表

### 优惠券

### 订单表

### 商品表

### 重量记录表

排错用的

### 系统类

### 活动

## 项目服务

### 通信服务

根据设备类型选择相应的执行器，根据协议解析请求，再把解析好的东西生成对象或JSON传给其他服务，只负责通信

### 设备服务

- 设备上下线

- 心跳

  每30s发送一次心跳
  
- 重量

  门关着，每90s发送一次重量；门开着，或关门后8秒内：每300ms发送一次
  
  
- 开关门

- 重量计算

  重量误差
  
- 商品计算

  各个货道商品数量=货道关门前重量-货道关门后重量/商品单重
  
- 库存计算

- 灯

- 加热

### app服务

- 用户创建

- 扫码

- 查看订单

- 用户账号查询

- 取消订单

  取消订单指的是跟支付宝/微信解约
  延迟队列
  当发送开门指令没有开门，或者没收到响应
  
- 充值

### 账户服务

- 账户创建

- 结单

- 优惠券抵扣

  系统设置好，不用用户选择优惠券，因为我们做的是免密支付，用户是无感的。
  根据业务设置：
  卷大于金额30%就不使用
  或者，1元的东西，也能使用20的现金卷
  
	- 现金卷

	- 团购劵

- 算余额

- 对账

  后面新加的功能：
  客户拿了东西，但是没扣他钱，一般只有补货时才能发现库存对不上，不能及时发现，所以要对账
  货道流水是一个很重要的对账的东西。
  
- 货道流水

  记录商品某一时刻订单本来有多少库存，购买了多少个，还剩多少个，补货 也会记入货道流水
  
### manager服务

后台管理

- 管理设备

- 管理商品

- 配置优惠卷

- 校准

  货柜上什么商品没有摆，发送一个清零指令，重量归零（去皮），使用校正砝码进行校正，看是否准确，记录校准订单表
  
- 补货

  根据货道表的 货道商品最大数量 和 补货触发阈值 进行补货
  
- 换品

### 通道服务

调用第三方服务

- 支付

	- 支付宝

	- 微信

- 短信

  发放优惠卷领取信息
  发送短信给运营人员补货
  
- 验证码

## redis

### 设备信息（string）

序列化成JSON串存到这：deviceId JSON字符串

- sn

- status

- 设备连接的通信服务

- 商品详情

- 心跳时间

  heart:sn1  30s
  
- 最后一次心跳时间

  heartlasttime
  
- 重量

- 最后一次重量

- 最后一次重量时间

  为啥要存：
  跟称不稳定有关，用于判断最后一次重量是否为关门后重量
  
- 是否开启加热

### 通信服务连接的设备（hash）

通道服务id：sn1 任意值，
		     sn2 任意值，
		     sn3 任意值，
		     sn4 任意值，
		     sn5 任意值，
通信服务1：1，2，3，  4，  5，  6，  7
通信服务2：8，9，10，11，12，13，14

### 通道服务信息连接的设备服务（hash）

### 订单信息(string)

把开门前重量记录一下，主要用于开门前开门后的重量对比

- 订单号

- 设备id

- 仓门id

- 开门前各个货道的重量

- userID

### Rdis分布式锁

- 仓门

  不用原生的setnx，用的是redission的那个锁
  扩展知识：watch dog的好处
  
	- 校准

	- 改价签

	- 购买商品

	- 补货

	- 换品

- 关门幂等

- 预授权回调

- 支付回调

### 阿里的配置信息

app key等信息

## [rocket mq](https://www.processon.com/diagraming/6434d0bff97848102a5d5f05)

通信服务都是通过rocket mq和其他服务发接消息

### 使用场景

- 延迟队列

  如果用户没点授权或者退出页面等一些情况，微信不会提示我们，所以需要我们发个30秒 延时消息，拉起授权页面后，如果30 秒后没授权，会取消订单。
  
### 顺序消息

开门消息
关门消息

## 分布式事务

### [强一致性](https://yq0pkza686.feishu.cn/minutes/obcn4m7dtr3197br78llgvk3)

在app服务创建用户成功后再去账户服务创建账户，两者要么一起成功，要么一起失败，使用 seata at 实现。
为什么不能用最终一致性？如果创建用户成功了，创建账户失败了，用户去下单会报错。

### 最终一次性

关门后，设备服务组装商品信息，发送一条事务性消息给 rocket mq，账户服务和补货如果消费失败，会一直重试，重试到一定次数，消息就会进入死信队列，也可以人工去结单，只需保证最终成功

## 分库分表

重量表数据量巨大，我们只保留一个月的重量记录，分成四张表，一个礼拜一个表（按照时间分），保证后面的排查

## 微信和支付宝的区别

### 下单次数

微信未授权或者授权中可以同时下三单，支付宝只能下一单


### 金额单位

微信是分，支付宝是元


### 支付完成详情

微信支付详情显示商品及支付金额，支付宝只显示总金额


### 退款

微信退款接口是异步的，支付宝退款接口是同步的。

## 了解

### netty io模型

- BIO（同步阻塞模型）

- NIO（同步非阻塞模型）

- AIO（异步非阻塞模型）

### netty 和 socket 的区别

Socket 是一种低级的网络通信技术，它提供了一种有效的方式来实现客户机/服务器通信，而 Netty 是一个基于 Java 的异步事件驱动的网络应用框架，它在 Socket 之上封装了大量的网络协议处理代码，使得开发人员更容易专注于业务逻辑实现。

## 项目难点

### 心跳机制

作用：监控设备是否在线
传统方案：把心跳存入 Redis 设置 30 秒过期时间，存在因网络抖动，导致 Redis 收不到心跳而非正常下线

新方案：实现 自我保护机制，把最后心跳时间存入Redis，定时任务每隔一分钟查看最后一次心跳时间是否在之前一分钟之内存入，心跳计数器统计心跳次数是否符合预期：
理想状态：2000台 4000次心跳
预期值：80% 3200次心跳
符合预期则不下线，避免无缘无故下线。

### 命令的不稳定性

因网络抖动，或者设备运行久了，出现命令不稳定

- 开门

  发送开门请求，回的是关门，可能只是当时没开，或者已经开了但是回的是关
  解决方案：查询门状态，一直查到5次，如果5次都还是未开门，则订单仓门状态改为异常，通知运营人员去检测
  发送了开门请求，但是没有任何响应结果
  解决方案：做一个 定时任务，每30s检查一次，如果订单仓门状态为未开门，但是订单状态是已授权，则订单仓门状态改为异常
  
  
- 重量

  发来的重量都是不稳定的（都是0）
  关门后睡眠0.5s，如果称还不稳定，取出最后一次重量时间是开门前，则在等2s
  
### 用户问题

重力柜出现的问题
从1货道拿个东西，放回一个相同重量的东西进去，不扣款
解决方法：
通过补货的时候，当发现商品不对，金额大直接报警，金额小，通过摄像头去看，然后查看开门记录，打电话解决，如果没法解决，属于正常损耗，因为我们选择通过重量去计算这种低成本方式，这种风险是可承受的。
但是又知道另一种规则，就是AI识别的柜子，它是通过摄像头，AI识别拿了什么商品，但是成本高，每AI一次就得花钱，这都是通过自己调研的。
但是很少有这种人。
从1货道拿了一个东西，但是不想要了，扔在了其他货道
解决方法：
一货道重量减少了该扣还是扣，二货道重量增多，标个异常报警，用户发现没买东西但是扣了钱，他联系了客服，那我们根据异常或者摄像头去核对，核实是对的，就进行退款。
但是AI柜不需要我们这样去维护，不会出现这些问题，每个货道可以放不同商品，但是我们一个货道只能放一种商品

另一种问题：
客户拿了东西，但是没扣他钱，一般只有补货时才能发现库存对不上，不能及时发现，所以要对账


- 异常

  大部分异常是通过报警通知运营人员来看重量信息，根据重量信息去对比，看拿了什么东西
  
	- 记入补偿表

	- 记入异常表

### 消息幂等

- 预授权回调幂等

  分布式锁还没释放，购买流程快走完了，又来一个预授权，这种情况做幂等：只有未授权我们才给它的状态进行改变，也可以通过分布式锁解决
  
- 关门幂等

  原方案：关门时，只有订单仓门状态为已开门才能更改订单仓门状态为已关门，后来发现，如果无缘无故的关门信息，不是正常流程下的关门，会丢失信息（极端情况：用户结束购买关了门，还未收到开门响应此时就收到关门响应）
  优化方案：
  非正常流程下的关门，只要收到关门结果，就去记录订单详情表，把订单状态改为异常，运营人员去核实仓门是否正常。
  那如何做幂等：加分布式锁
  
  
- 支付回调幂等

  双重策略：
  加分布式锁，
  同时用数据库行锁防止同时修改，如：update paystatus =‘已支付’ where paystatus = ‘支付中’（不能先查询，再更新）
  因为我们项目的特殊性，做的是免密支付，扣失败了，支付宝每小时回扣一次，直到成功，所以几乎返回成功，没有返回失败的情况。
  一般收到一条失败，又收到一条成功，都做报警处理，去微信/支付宝查询订单是什么情况，再对订单做一个修复。
  
- 账户服务

### 重量误差

重量误差，是个线性的计算，如果50克少了20，认为是合理误差，100克少了40，也认为是合理误差，如果1千克少了400克，则认为是拿了商品，本着先去扣钱的原则，如果扣错了，那就让用户通过客服解决。
一般误差大时，会通知运营人员进行校准


### jvm调优

我们监控到了，告诉运维去调的
设备 100 -> 600台，设备不断的发心跳发重量，随着连接通信服务的设备增多，CPU执行时间变长，导致对象生存周期变长，本来能及时回收却不能回收，也是因为设备的增多，创建的对象越来越多，青年代很快就满了，每次young gc因survivor区空间不够，对象提前进入老年代，但是又因为对象不是长期存活的对象，所以老年代也很快就满了，频繁full gc，导致OOM
优化：
由于我们项目老年代存活的对象少，空间浪费，年轻代创建的对象多且存活时间短，空间2：1改成1：1，同时让survivor区能够容纳多点对象，调整eden区和survivor区比例8：1：1改成3：1：1
通信服务做集群，每台机器最多300台

### 死锁

如何检测到的：MySQL命令SHOW PROCESSLIST；arthas工具：thread
老规则：扫码添加到购物车，然后结单
死锁场景：A先添加a在加b，B先加b再加a，两人同时去扣库存就会发生死锁。
解决方法：对购物车商品进行排序

### MySQL调优

比如说更新数据库字段 更新什么字段就更新什么字段  而不是读取一个对象 改里面的一个变量 再把这个对象全部更新

### 分布式锁

### 线程问题

比如说心跳计数器。多个设备去请求这个接口。那这个共享变量是不是有安全问题
可以使用redis 存储这个变量
因为redis单线程的

## 部署

机器：4核8g
通信服务：它需要建立socket连接占内存，内存高点，4核12g
通信服务和设备服务都要实时处理心跳重量，所以做了集群。

## 订单量

如果是饮料，一两百单左右，优惠力度大，卷多，两三百单左右
平均50单，2000台设备，就是10万单

## 为什么不用varchar做主键

先谈谈int自增作主键的好处
插入数据都在后面插入，而varchar它是不确定的，插入会使得数据移动
减少页分裂
主键不冲突
利于分库分表，int是有序，只要使用值范围进行分页

## 存在并发

### 心跳计数器

不能用int类型来存
用原子类AtomicInteger来存
但是设备服务不止一台，分布式情况不合适，需要用到redis，因为它是单线程的（string）

### 分布式锁

### rocketmq顺序消息

问题：先消费关门信息，再消费开门信息

## xxl-job原理

xxl-job分布式任务调度服务由调用中心和执行器组成，调用中心负责按任务调度策略向执行器发放任务，执行器负责接收并执行任务。
部署并启动xxl-job调度中心（Java工程）。
在微服务中添加xxl-job依赖，并配置执行器。
启动微服务，执行器向调度中心上报自己。
在微服务中写一个任务方法并用xxl-job的注解标记为任务，并指明执行任务的方法名称。
在调度中心配置任务调度策略，是每隔多长时间执行还是固定时间去执行，比如每隔1小时执行一次、每天0点执行等。
在调度中心启动任务。
调度中心根据任务调度策略，下发任务给执行器。
执行器收到后就开始执行。

