# 线程池

## 为什么会有多线程？

CPU 是一种很宝贵的资源，线程任务不是时刻都在使用 CPU，可能中途在等待其他操作，此时 CPU 是空闲的，就可以让 CPU 执行其他线程的任务。

## 为什么有线程池？

new 线程是有开销的，线程栈内存默认是 1 M，所以要有线程池来管理线程的生命周期，提高资源利用率，我们只需要往里面提交任务。

参考资料：
Holis：
https://www.yuque.com/hollis666/hgtuok/fb5th6

## 线程池核心参数

corePoolSize 核心线程数
maxmumPoolSize 最大线程数
workQueue 等待队列（有界队列、无界队列）
handler 拒绝策略
CallerRunsPolicy：哪个线程提交的任务就哪个去执行。
AbortPolicy：丢弃任务并报异常。RejectedExecutionException。
DiscardPolicy：直接丢弃任务。
DiscardOldestPolicy：丢弃等待队列里面最老的一个任务并加入一个新任务。
threadFactory 线程工厂
unit 等待单位
keepAliveTime 等待时间
当线程池线程数量超过最大线程数，并且空闲时间达到等待时间时，多余空闲线程会被回收，直到数量为核心线程数。
参考资料：
Holis（线程数设定）：
https://www.yuque.com/hollis666/hgtuok/zanzx4giay7gixf6

## 线程池工作流程

示例：核心线程数 5，
	   最大线程数 10，
	   有界队列 100
当第一次提交任务时，会 new 一个线程出来，然后把任务放到线程里面让线程跑起来；一直 new 到 5 个，核心线程满了，任务就要去等待队列等着，如果是有界队列，且队列满了 100 个，此时当第 106 个任务进来了，然后又创建线程，直到最大线程也满了，就走拒绝策略了。


## 线程池里面的线程执行任务是出现异常了怎么办？

抛出异常，然后终止线程，如果还有任务需要执行，那就会补一个新的线程。

## @Async 注解

在业务上写一个异步方法。
原理：
生成一个动态代理，然后代理原来的方法异步去执行；
注：jdk 代理，基于接口；cglib 基于继承。
通过 Spring 默认配置的线程池（等待队列是无界的）里面的线程执行。
注：有 oom 的风险，所以线程要自己去管理，声明一下线程池，项目中针对 @Async 注解提前配置好线程池。就是因为组员搞了这个异步，结果线上 oom。
提示：造成 OOM 的原因要么是上游快（QPS 提升了），要么是请求下游超时（请求阻塞）。

