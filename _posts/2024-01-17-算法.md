# 算法

参考资料：
代码随想录：
https://programmercarl.com/

## [面经](https://lvliu-kun.github.io/2024/01/17/%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F.html)

## [排序算法](https://lvliu-kun.github.io/2024/01/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html)

## 数组

### 704.二分查找

返回数组中要查找的指定值。
二分法：使用二分法前提是数组是有序的，且无重复元素；根据中间元素不断缩小排查范围（目标值大于则在右半部分，小于则在左边部分），直到找到目标值。
双指针法：左指针指向范围左边界，右指针指向范围右边界。

### 27.移除元素

移除数组中指定的值。
暴力法：遍历，遇到要移除的元素，后面元素全部前移，需要两个 for 循环，时间复杂度是 O(n²)。
双指针法：定义一个指针用来更新元素，一个指针用来遍历出要更新的元素，只需一个 for 循环。

### 977.有序数组的平方

返回保持非递减顺序的整数数组元素平方后的新数组。
左右双指针法：定义左指针指向可能是负数的这端，右指针指向可能正数的这端；指针各自指向的元素平方之后进行比较，大的添加到新数组，同时对应的指针右移或左移一位，继续循环。

### 209.长度最小的子数组

返回正整数数组中 元素和 >= target 的连续子数组中 最小的长度。
滑动窗口：维持窗口内的元素和 < target，如果 >= 则记录子数组长度，同时调节窗口。
双指针法：左指针指向窗口左边界，右指针指向窗口右边界；这里的双指针移动起来像是窗口的滑动，所以称为滑动窗口，是双指针法的一种。

### 59.螺旋矩阵 II

返回一个由 1 ~ n² 顺时针顺序螺旋排列的 n × n 的矩阵。
模拟过程：要控制好循环不变量，确定循环的圈数、每圈的起始坐标、四边遍历的长度。

## 链表

经常能用到虚拟节点，一般是为了不用单独处理头节点。

### 203.移除链表元素

双指针法：定义一个虚拟节点为新的头节点，一个指针指向前一个节点，一个指针指向遍历到的当前节点。

### 707.设计链表

设计单向链表，定义一个虚拟节点为头节点；设计双向链表，定义一个虚拟节点为头节点，一个虚拟节点为尾节点，插入、获取、删除节点哪头近就选择从哪头遍历。单向链表通过前节点插入、删除节点，双向链表不用。

### 206.反转链表

双指针法：一个指针指向前一个节点，一个指针指向遍历到的当前节点；处理遍历到的节点，处理前先用一个辅助变量保存下一个节点。
递归：传入前一个节点和当前节点，同样，处理节点前先用一个辅助变量保存下一个节点。
回溯：只传人当前节点，一直递归到尾节点，然后在回溯的时候处理节点。

### 24.两两交换链表中的节点

返回两两交换其中相邻节点后的链表。
模拟过程：两个为一组进行交换，0 个或只有 1 个不用交换。如果用的是迭代，从左边开始交换，交换好的组重新指向下游，下游是还没交换好的，下游交换好后，上游还要重新指向下游；如果用的是是回溯，回溯的过程都是交换好的组，回溯的时候只需指向一次。

### 19.删除链表的倒数第 N 个结点

双指针法：一个指针用来指向前一个节点，一个指针用来遍历节点；先让用来遍历的指针移动 N，然后两个指针一起移动，直到遍历完，最终得到要删除的节点的前一个节点，然后处理节点。

### 面试题 02.07. 链表相交

返回两个链表相交的起始节点。

同 160.链表相交。
模拟过程：定义一个指针用来遍历第一个链表，一个指针用来遍历第二个链表。首先遍历获取两个链表的长度，然后遍历消除它们的长度差，让两个指针平齐位置，然后再遍历，如果两个指针指向同一个对象则说明这是相交点。

### 142.环形链表 II

返回链表中环入口的节点。
快慢双指针法：定义一个快指针，一个慢指针，快指针比慢指针多移动一个节点。如果快指针为空或者快指针的下一个节点为空，则说明没环，否则有环。如果有环，那么它们一定会相遇，因为快指针移动两步，慢指针移动一步，快指针是一步一步追上慢指针的；相遇后，定义一个指针指向头节点，用来遍历出环入口节点，同时移动这个指针和慢指针，如果相遇了，则说明相遇点是环入口（
公式推导：假设头节点到环入口需要移动的节点数为 x，环入口到快慢指针相遇点需要移动的节点数为 y，快慢指针相遇点到环入口需要移动的节点数为 z，则快慢指针相遇时，慢指针移动的节点数为 x + y，快指针移动的节点数为 x + y + n ( z + y )，得到等式 ( x + y ) * 2 = x + y + n ( z + y )，求得 x = z + ( n - 1 ) ( z + y )，因为快指针至少要移动一圈才能和慢指针相遇，所以 n >= 1 ；为什么慢指针与快指针相遇前走过的节点数是 x + y，而不是移动了几圈再与快指针相遇，即 x + y + n ( z + y )，因为如果快慢指针同时从环入口移动，则还会在环入口相遇，此时慢指针移动一圈，快指针移动两圈，不存在慢指针移动几圈后才与快指针相遇；如果慢指针从环入口开始移动，快指针从环内除环入口任意节点开始移动，假设快指针到环入口需要移动的节点数为 k，一圈的节点数为 w，当快指针移动的节点数为 k + w，即移动完一圈且所在节点是环入口，此时慢指针移动的节点数是 ( k + w ) / 2，即移动的节点数 < w，慢指针还没移动完一圈，说明已经和快指针相遇了；综上所述，慢指针与快指针相遇前走过的节点数是 x + y。
）。

### [循环单向链表(约瑟夫问题)](file:///N:/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/byLv/%E5%BE%AA%E7%8E%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8(%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98).md)

## 哈希表

### 242.有效的字母异位词

判断一个词是否是另一个词的字母异位词（两个词中每个字符出现的次数都相同）。
哈希表：定义一个长度为 26（因为字母总共就 26 个）的数组作为哈希表，把词映射到哈希表中，同时统计词中字母出现的次数，判断一个词是否是它的字母异位词，只需在映射位上做减法，每次都减 1，最后遍历这个哈希表，如果元素都为 0，那么是字母异位词，否则不是。
注：383.赎金信 是子集问题，这里不是子集问题，处理逻辑不一样。

### 349.两个数组的交集

返回两个数组的交集且交集的每个元素是唯一的。
哈希表：用一个 set 给数组作映射，然后定义一个 set 用来保存交集，获取一个数组与它的交集，只需看数组中的元素是否存在映射，有则添加到交集，最后把交集转换为数组。

### 202.快乐数

判断一个正整数是不是一个快乐数（如果一个正整数每次都把替换为它每个位置上的数字的平方和，直到这个数为 1，那么它是快乐数；如果它不是快乐数，这个正整数可能无限循环）。
哈希表：因为可能是无限循环，说明这个正整数会重复，定义一个 set 来记录是否重复，如果重复了，那么就不是快乐数，如果这个正整数能为 1，则是快乐数。

### 1.两数之和

返回整数数组中两个和为 target 的元素下标（同一元素在答案中不能重复，一个数组只对应一个答案）。
哈希表：定义一个 map 用来存储元素，遍历数组，通过 target 减去当前元素计算出另一个整数，看它在是否在 map 中，在则返回结果，不在则把当前元素添加到 map  中。

### 454.四数相加 II

返回从四个整数数组分别取出的四个元素的和为 0 的元组数。
哈希表：定义一个 map 用来映射，遍历 a 数组和 b 数组计算出两个数组元素的和，把和映射到 map 里，同时统计出现的次数，然后定义一个变量来累加次数，遍历 c 数组和 d 数组，通过计算 0 减去这两个数组元素和的值，判断这个值是否存在映射，有则累加次数。

### 383.赎金信

判断一个字符串是否可以由另一个字符串里面的字符组成（每个字符只能用一次）。
哈希表：定义一个长度为 26（因为字母总共就 26 个）的数组作为哈希表，把字符串映射到哈希表中，同时统计字符串中字符出现的次数，判断一个字符串是否可以由它里面的字符组成，只需在映射位上做减法，每次都减 1，做减法之前，如果字符出现的次数 <= 0，则这个字符串不可以由另一个字符串里面的字符组成。

### 15.三数之和

返回整数数组中三个元素（同一元素不能重复）和为 0 的不重复的三元组。
双指针法：定义一个 list 集合保存三元组，先对数组从小到大排序；然后遍历数组，首先进行剪枝，如果当前元素 a > 0，则说明最小的数都是正数，后面三数之和永远大于 0，直接方法返回；接着增加对当前元素的去重逻辑；再定义一个左指针指向 i + 1 的位置，一个右指针指向数组末尾，在数组中寻找 a, b, c，即 a = nums[i]，b = nums[left]，c = nums[right]；计算三数之和，如果和 < 0，则 left 右移；> 0，则 right 左移；= 0，则把这个三元组添加到集合，然后对 b, c 去重，去重之后左右指针收缩。

### 18.四数之和

返回整数数组中四个元素（同一元素不能重复）和为 target 的不重复的四元组。
双指针法：定义一个 list 集合保存四元组，先对数组从小到大排序；然后遍历数组，首先进行剪枝，如果当前元素 a > target 且是非负整数，则说明最小的数都 > target，后面四数之和永远大于 target，直接方法返回；接着增加对当前元素的去重逻辑；然后从 i + 1 位置开始遍历数组，首先也是进行剪枝，如果当前元素 b 和元素 a 的和 > target 且 b 是非负整数，则说明最小的和都 > target，后面四数之和永远大于 target，结束循环；接着增加对当前元素的去重逻辑；再定义一个左指针指向 j + 1，一个右指针指向数组末尾，在数组中寻找 a, b, c, d，即 a = nums[i]，b = nums[j]，c = nums[left]，d = nums[right]；计算四数之和，如果和 < target，则 left 右移；> target，则 right 左移，= target，则把这个四元组添加到集合，然后对 c, d 去重，去重之后左右指针收缩。

## 字符串

### 344.反转字符串

将字符串反转（字符串是以字符数组形式给出）。
左右双指针法：定义左指针指向数组开头，右指针指向数组末尾，通过交换元素进行反转，两边同时遍历，相互交换左右指针指向的元素。

### 541.反转字符串 II

返回根据规则反转后的字符串，规则是反转每 2k 个字符里面的前 k 个字符，如果不足 2k，依然反转前 k 个字符，如果不足 k 个字符，则反转所有字符。
左右双指针法：首先把字符串转换为字符数组，然后遍历数组，start 的步长是 2k，定义左指针指向 start，右指针指向 start + k - 1 或 c.length - 1，谁小指向谁，接着循环，交换左右指针指向的元素。

### [54.替换数字（第八期模拟笔试）](file:///N:/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/byLv/code/data-structures-and-algorithms/src/main/java/com/byLv/algorithms/string/ReplaceNumber.java)

返回把包含小写字母和数字的字符串里面的数字替换为 number 后的字符串。
填充新数组：定义一个 StringBuilder 用来填充，遍历字符串，如果是数字，则填充 number，不是则填充原有字符。

### 151.反转字符串中的单词

返回反转字符串中的单词后的字符串，返回的字符串中只有单词之间才有一个空格。

考验对字符串的操作：
去除多余空格 -> 整体反转 -> 局部反转：先去除多余空格，然后整体反转，接着遍历，进行局部反转。
整体反转 -> 局部反转 -> 原数组填充单词（同时也去除了多余空格）：把字符串转换为字符数组，先整体反转，然后遍历，接着进行局部反转，同时进行原数组填充单词。
从后往前遍历字符串、新数组填充单词（同时也去除了多余空格）：把字符串转换为字符数组，定义一个新数组来填充单词，然后从后往前遍历字符串，接着进行新数组填充单词。
注：反转字符串参照 344.反转字符串和 541.反转字符串 II。

### [55.右旋字符串（第八期模拟笔试）](file:///N:/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/byLv/code/data-structures-and-algorithms/src/main/java/com/byLv/algorithms/string/RightHandedString.java)

返回把字符串后面 k 个字符移到字符串前面后的字符串。
整体反转 -> 局部反转：先整体反转，然后根据 k 确定两个要反转的部分进行局部反转。
注：也可以先局部反转 -> 整体反转；或者新数组填充。

### 28.找出字符串中第一个匹配项的下标

判断一个字符串是否是另一个字符串的一部分，如果是则返回第一个匹配的首字母下标。
KMP：首先构建前缀表，然后根据前缀表模式串和文本串进行匹配。时间复杂度是O(n)，暴力的解法是O(n²)。
补充：KMP的主要思想是当模式串与文本串不匹配时，不用从头开始匹配，而是根据前缀表里的信息进行匹配，有了前缀表，就知道模式串该从哪重新开始匹配；前缀表记录了模式串当前元素之前（包括当前元素）的元素 相同的前后缀有多大长度，前缀——以第一个字符串开头但不包含最后一个字符的连续子串，后缀——以最后一个字符结尾但不包含第一个字符的连续子串。

### 459.重复的子字符串

判断一个字符串是否由它的一个子串重复多次构成。
前缀表：首先构建前缀表，如果字符串有最长相同的前后缀，并且它由自己的一个子串重复多次构成，则 数组长度 - 相同的前后缀的长度 就是最小重复子串的长度，数组长度也可以被这个长度整除。

## 双指针法

### 27.移除元素

### 344.反转字符串

### 54.替换数字（第八期模拟笔试）

### 151.反转字符串中的单词

### 206.反转链表

### 19.删除链表的倒数第 N 个结点

### 面试题 02.07. 链表相交

### 142.环形链表 II

### 15.三数之和

### 18.四数之和

## 栈与队列

### 232.用栈实现队列

用两个栈实现队列的操作。

考验的是对栈和队列掌握的程度。
模拟：定义一个栈用来存储元素，一个栈用来移除元素；添加元素到队列，则直接往存储元素的栈中添加；移除队列的头元素，则先判断移出元素的栈是否为空，为空则把存储元素的栈中存的元素转储到移除元素的栈，然后从移除元素的栈中移除；获取队列的头元素，则也是先判断移出元素的栈是否为空，为空则把存储元素的栈中存的元素转储到移除元素的栈，然后从移除元素的栈中获取；判断队列是否为空，则直接判断两个栈是否为空，一个为空则为空，两个不为空才不为空。

### 225.用队列实现栈

用两个队列实现栈的操作。

考验的是对栈和队列掌握的程度。
模拟：定义一个队列用来添加元素，一个队列用来移除元素；添加元素到栈，则先把元素添加到添加元素的队列中，然后把移除元素的栈中的元素添加到添加元素的队列中，接着交换两个队列；移除栈顶的元素，则直接从移除元素的队列中移除；获取栈顶的元素，则直接从移除元素的队列中获取；判断栈是否为空，则直接判断移除元素的队列是否为空。

### 20.有效的括号

判断字符串里的括号是否有效（括号是配对且正确闭合的）。
栈：定义一个栈用来匹配括号，然后遍历字符串；如果括号是左括号，则往栈中添加一个右括号；如果括号是右括号，则和栈顶元素配对（栈为空，说明右括号多余，则无效），如果不匹配，则无效，如果匹配，则弹出配对的括号；最后遍历结束，如果栈为空，则有效；如果不为空，说明左括号多余，则无效。

### 1047.删除字符串中的所有相邻重复项

返回一直重复删除字符串中相邻且相同的字母后的字符串。
栈：定义一个栈用来匹配相邻且相同的元素，然后遍历字符串，和栈顶元素匹配（栈为空，则入栈）；如果与栈顶元素相同，则把匹配的字母弹出；如果不相同，则入栈；最后遍历结束，栈里面的元素就是重复删除后剩余的字母。
双指针法：定义一个指针 slow 用来更新元素，一个指针用来遍历，slow 初始化为 -1，然后遍历，如果 slow >= 0 并且 slow 指向的元素和当前元素相等，则 slow 左移一位，否则 slow 右移并且更新值为当前值。
注：除了用栈，也可以用其他数据结构当栈，如 stringBuilder。

### 150.逆波兰表达式求值

返回逆波兰表达式字符串计算后的值。
栈：遍历字符串，如果当前元素是运算符，那么弹出栈顶前两个元素进行计算，把计算后的值入栈，否则把当前元素直接入栈；遍历结束，栈中的值就是要返回的值。

### 239.滑动窗口最大值

返回整数数组中滑动窗口中的最大值。
单调队列：
维护元素下标：定义一个单调队列维护滑动窗口的最大值下标（队列里面下标对应的数组元素是从大到小的），定义一个数组保存滑动窗口最大值；然后遍历数组，如果队列头元素不在滑动窗口范围，则弹出，接着当前元素和队列尾元素对应的数组元素比较大小，如果更大，则弹出队列尾元素，直到比它小，再接着把当前元素下标添加到队列，然后保存队列头元素对应的数组元素，它就是滑动窗口最大值。
维护元素值：定义一个单调队列维护滑动窗口的最大值（队列里面的元素是从大到小的），定义一个数组用来保存滑动窗口最大值；然后遍历数组，如果队列头元素不在滑动窗口范围，则弹出，接着当前元素和队列尾元素比较大小，如果更大，则弹出队列尾元素，直到比它小，再接着把当前元素添加到队列，然后保存队列头元素，它就是滑动窗口最大值。

### 347.前 K 个高频元素

返回整数数组前 k 个高频元素。
优先队列最小堆：首先定义一个 map 用来统计数字出现的频率，然后遍历数组进行统计；接着根据频率对 map 里面的元素进行排序，首先定义一个优先队列用来排序，并指定队列是最小堆，然后遍历 map，把里面的元素添加到队列，并维持队列 k 个大小，当超出 k 个大小，则弹出堆顶元素；最后定义一个数组存放前 k 个高频元素，倒序遍历它把堆顶元素添加到里面。
补充：也可以用最大堆，但是它不能只维护 k 个元素，只能维护所有元素，因为每次弹出堆顶元素都是最大值，而我们要的是前 k 个高频元素；而且使用最大堆就要对所有元素都进行排序，而最小堆只需对 k 个元素排序。

## 二叉树

二叉树的深度：根节点到某个节点的节点数。
二叉树的高度：某个节点到叶子节点的节点数。
求二叉树的最小深度或最大深度也是求二叉树的最小高度或最大高度，即可以从上到下去查（前序遍历），也可以从下到上去查（后序遍历）；而求高度只能从下到上去查（后序遍历）。

### [二叉树的遍历方式](file:///N:/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/byLv/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F.md)

- 深度遍历

  递归法、迭代法（用栈实现）、统一的迭代法（要处理的节点入重新入栈后，再把空节点入栈作为标记）。
  前中后序遍历中的前中后指的是中间节点。
  
	- 前序遍历

	- 中序遍历

	- 后序遍历

- 广度遍历

  递归法、迭代法（用队列实现）
  
	- 层序遍历

		- 102.二叉树的层序遍历

		  递归法：在前序遍历的基础上修改，值存到对应那层的结果集上。
		  迭代法：定义一个队列用来层序遍历，根节点添加到队列初始化，循环，然后遍历队列，处理当层各个节点，处理的同时把子节点添加到队列，再然后接着循环，直到队列为空。
		  
		- 107.二叉树的层序遍历 II

		  返回二叉树自底向上的层序遍历。
		  迭代法：反转自顶向下的层序遍历。
		  
		- 199.二叉树的右视图

		  返回二叉树右侧节点值。
		  迭代法：进行层序遍历，收集每层最后一个元素。
		  
		- 637.二叉树的层平均值

		  返回二叉树每一层节点的平均值。
		  迭代法：进行层序遍历，每层求和后计算平均值。
		  
		- 429.N 叉树的层序遍历

		  迭代法：层序遍历。
		  
		- 515.在每个树行中找最大值

		  迭代法：进行层序遍历，记录每层的最大值。
		  
		- 116.填充每个节点的下一个右侧节点指针

		  返回满二叉树每个节点和下一个右侧节点相连后的树。
		  迭代法：进行层序遍历，把每个节点和下一个右侧节点相连（可以借助前指针，也可以不借助前指针）。
		  
		- 117.填充每个节点的下一个右侧节点指针 II

		  返回二叉树每个节点和下一个右侧节点相连后的树。
		  迭代法：进行层序遍历，把每个节点和下一个右侧节点相连（可以借助前指针，也可以不借助前指针）。
		  
		- 104.二叉树的最大深度

		  返回二叉树的最大深度。
		  迭代法：进行层序遍历，每遍历一层深度 +1。
		  
		- 111.二叉树的最小深度

		  返回二叉树的最小深度。
		  迭代法：进行层序遍历，每遍历一层深度 +1，如果节点没有左子节点以及右子节点，即是叶子节点，则直接返回。
		  
### 226.翻转二叉树

递归法（前序遍历模版上改动处理逻辑）：处理中间节点时，交换左右子节点。
统一迭代法（前序遍历模版上改动处理逻辑）：处理中间节点时，交换左右子节点。
注：前后序可以，中序不行，因为交换左右子节点后，传入的右子节点是交换前的左子节点。
迭代法（层序遍历模版上改动处理逻辑）：处理节点的时候交换左右子节点。

### 101.对称二叉树

检查二叉树是否对称。
递归法：前序遍历改动，使用双指针遍历。
迭代法：不管是使用用单向队列，还是双向队列，亦或是栈实现，都是作为容器，成对存入，成对取出。

### 104.二叉树的最大深度

递归：前序遍历记录最大深度；后序遍历获取左右子树中最大的深度，返回 最大深度 + 1。

### 111.二叉树的最小深度

递归：前序遍历当是叶子节点时更新最小深度；后序遍历获取左右子树中最小的深度，返回 最小深度 + 1（对非叶子节点，只是左节点为空要增加处理逻辑）。

### 222.完全二叉树的节点个数

遍历二叉树
注：用栈的迭代法，可以不用按照严格的遍历方式，只需把栈当容器使用，统计个数。

### 110.平衡二叉树

判断是否为平衡二叉树。


