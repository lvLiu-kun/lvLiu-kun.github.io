# [byLv](file:///P:/Java/MySQL/MyNotes)

## 执行一条 select 语句，期间发生了什么？

客户端和 MySQL 服务建立 TCP 连接后，当 MySQL 收到 sql 时：
首先会解析 sql 语句的第一个字段，如果是 select，就会先去查缓存（如果 select 语句执行过，缓存就会记录——key 为 select 语句，value 是查询结果），如果命中，直接返回 value 给客户端；
注：如果是更新比较频繁的表，只要一更新表，缓存就会被清掉，所以缓存的命中率很低；MySQL 8.0 开始没有查询缓存这步了。
没有命中则解析器开始解析 select 语句，首先是词法分析，识别出字符串里的关键字，如 select name from student 中的 select 和 from 两个关键字；然后是语法分析，语法分析器会根据语法规则判断 select 语句是否正确，没有问题就会构建语法树（方便后面模块获取信息）；
接着进入执行 sql 语句流程，首先是预处理阶段（prepare），预处理器检查表或字段（如果是 *，则扩展表上所有字段）是否存在；然后是优化阶段（optimize），优化器将 sql 执行方案确定下来（如走哪个索引）；最后是执行阶段（execute），执行器和存储引擎交互开始执行 select 语句了，执行器每读取到存储引擎中的一条记录都会判断是否符合条件，符合则返回客户端，然后一直重复。

参考资料：
小林 coding：
https://xiaolincoding.com/mysql/base/how_select.html#%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1-select-%E8%AF%AD%E5%8F%A5-%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88

## InnoDB

### 为什么 MySQL 采用 B+ 树作为索引？

索引是保存在磁盘上的，当我们通过索引查找某行数据时，就需要先把索引从磁盘读到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，每访问一个节点，都对应一次磁盘 I/O ，树的高度就等于每次查询数据时磁盘 I/O 次数，B+树比较矮胖（一般千万级别的数据，也就 3 层，阿里代码规范 500 万数据就要分库分表），可以减少磁盘 I/O 次数，提升性能。
不仅能高效地查询某一个记录，而且能高效地执行范围查找。
注：
为啥不用数组？有序数组二分查找时，每次都要不断计算中间的位置；并且数组插入元素后的所有元素都得后移一位，性能是灾难性的。
为啥不用红黑树（平衡二叉搜索树的一种）？起初，先考虑的是二叉搜索树,它有一个极端情况，每次插入元素都是树中最大/最小元素，会退化成链表，时间复杂O(n)，后来，提出了平衡二叉搜索树，如红黑树，每个节点的左子树和右子树的高度差不能超过 1，虽然维持了查询时间复杂度O(lgn)，但是元素越多，树越高，I/O次数也越多，因为它每个节点最多只能有两个子节点。
为啥不用B树？它的节点可以有M个子节点，同样多的元素，它的高度比平衡二叉树高度要低，但是每个节点都包含数据（索引+记录），要读到有用的索引数据，同时需要花费更多的磁盘 I/O 读取记录数据，并占用内存资源。
因此用B+树，叶子节点才放数据（索引+记录），非叶子节点只放索引；并且所有索引都会在叶子节点出现，叶子节点之间构成一个有序的双向链表。相比于B树，非叶子节点可以存更多的索引，因此更加矮胖，一般千万级别的数据，也就3层，阿里代码规范500万数据就要分库分表。


参考资料：
小林 coding：
https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html#%E4%B8%BA%E4%BB%80%E4%B9%88-mysql-%E9%87%87%E7%94%A8-b-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95

### InnoDB 是如何存储数据的？

数据是以数据页（16 KB）的形式存在磁盘上的。
参考资料：
小林 coding：
https://xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84

### [innodb和myisam的区别](https://lvliu-kun.github.io/2023/09/23/innodb%E5%92%8Cmyisam%E7%9A%84%E5%8C%BA%E5%88%AB.html)

## 索引

索引建的越多越好吗？

参考资料：
小林 coding：
https://xiaolincoding.com/mysql/index/index_interview.html#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81-%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95

### 回表

如果查询的字段不在非聚簇索引里，则通过非聚簇索引叶子节点中的主键 id 回到聚簇索引中查找，这个过程就叫作回表。

### 索引覆盖

在非聚簇索引上能查到数据，不用回表，就叫索引覆盖（是一种现象）。

### 索引下推

MySQL 5.6 后，能走索引就走索引，避免全表扫描或者减少回表次数。

### 索引分类

- 聚簇索引（主键索引）

  叶子节点存放索引和所有数据。
  
- 非聚簇索引

  叶子节点只存放索引和主键 id。
  
	- 唯一索引

	- 联合索引

## 锁

读未提交隔离级别：使用行锁；
读已提交隔离级别：使用行锁；
可重复读隔离级别：使用行锁、间隙锁、临键锁。

参考资料：
小林coding：
https://xiaolincoding.com/mysql/lock/mysql_lock.html

### 表锁

rr 级别下如果没走索引，就会锁表。

### 行锁

锁的是索引。

### 间隙锁

select ... where id = 5 for update；
如果没读到数据，就会锁住跟这条数据相邻的记录（比如相邻的记录是 3 和 7）之间的间隙，就叫间隙锁。
select ... where id > 5 for update；
大于 5 范围都会被锁住了。
注：锁定范围是左开右开。
注：间隙锁之间不互斥，和更新、插入等写语句互斥。

### 临键锁（next-key locks）

行锁 + 间隙锁。
注：锁定范围是左开右闭。

## [数据库设计三范式](https://lvliu-kun.github.io/2022/09/23/MySQL_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F)

## [事务](https://lvliu-kun.github.io/2022/08/15/MySQL%E4%BA%8B%E5%8A%A1.html#%E4%BA%8B%E5%8A%A1transaction)

### [事务特性（acid）](https://lvliu-kun.github.io/2022/08/15/MySQL%E4%BA%8B%E5%8A%A1.html#5%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7)

- 原子性（Atomicity）

- 一致性（Consistency）

- 隔离性（Isolation）

- 持久性（Durability）

### [事务隔离级别](https://lvliu-kun.github.io/2022/08/15/MySQL%E4%BA%8B%E5%8A%A1.html#6%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)

- 读未提交（read uncommitted）

- 读已提交（read committed）

- 可重复读（repeatable read）

	- 幻读

	  加锁解决幻读，直接不让插入：select for update（当前读）。
	  
- 序列化读/串行化读（serializable）

### MVCC

mvcc（多版本并发控制），支持数据并发修改下的快照读，它能控制多个事务同一时间读取的数据，它是通过 undo log 和 readview 保证的。

undo log 是每行数据都有一个隐藏事务ID加指向上个事务ID的指针形成的版本链。

readview 有四个核心参数：
最小事务ID（当前活跃列表的最小事务ID），
最大事务ID（当前版本链上最新数据的事务ID+1），
当前活跃事务ID（当前事务的ID），
当前活跃事务列表（当前未提交的那些事务ID）。

每个事务开启后修改数据都会生成 undolog 版本，通过 readview 进行读取版本链上的数据，如果小于最小事务ID，就读，如果大于最大事务ID，不读，然后再比较当前活跃事务列表，如果在，不读；如果是当前活跃事务 ID，当然读，自己读自己的。rr隔离级别下第一次查询时生成一次 readview，解决了不可重复读，且解决了快照读下的幻读，rc下每次查询都会生成一个新的readview，解决了脏读。

### 事务实现原理

原子性：每当事务修改时，会产生 undo log （回滚日志），需要回滚时，会根据 undo log 进行反向语句的逻辑操作，如：insert 一条记录就 delete 一条记录。
隔离性：MVCC 或 锁机制。
持久性：在事务的执行过程中，便开始写 redo log（重做日志文件）文件中。在发生故障时，如果脏页未写入磁盘，重启 MySQL 服务后，根据 redo log 进行前滚，并将事务未落盘的数据进行持久化。
一致性：原子性 + 隔离性 + 持久性。

## 日志

### undo log

记录各行数据的版本。

### redo log

物理日志
为什么有redo log日志？因为修改数据都是在内存操作的，然后再写入磁盘，如果每次修改都直接写入磁盘（随机写），是很慢的，所以我们先写入 redo log（顺序写），通过 redo log 再异步落盘，保护磁盘。

### bin log

bin log 记录的是表结构变更（CREATE、ALTER TABLE等)以及表数据修改（INSERT、UPDATE、DELETE）的逻辑日志，主要目的是主从复制和系统恢复。
bin log 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改。


### 事务两阶段提交

保证 bin log 和 redo log 一致性写入，确保主从数据库之间的数据一致。
如果没有两阶段提交：
写入 redo log 成功，但没来得及写入 bin log ，系统奔溃重启后，redo log 把最新数据更新到主库；由于 bin log 没写成功，主从同步的时候，导致主从数据库之间数据不一致。
没来的及写入 redo log，但写入 bin log 成功，系统崩溃重启后，由于 redo log 还没写，主库记录还是旧数据；bin log 主从同步把新数据同步到从库，导致了主从库之间数据不一致。
两阶段如何保证 bin log 和 redo log 一致性写入？
崩溃后，如果 redo log 写失败了，此时直接回滚事务；如果 redo log 成功（预提交），bin log 失败，那么看 bin log 是否完整，不完整，则比较 redo log，然后完善 bin log，达到一个前滚的效果，然后再次写 redo log（真正提交）；完整，则直接再次写 redo log（真正提交）。


- Prepare阶段

  首次写 redo log，并将状态标记为 prepare（预提交）。
  
- BinLog持久化阶段

  生成 bin log。
  
- Commit阶段

  再次写 redolog，主要是将状态从 prepare 改为 commit（真正提交）。
  
## 主从同步

流程：
主库提交事务会写 bin log，然后 bin log 被一个 dump 线程推送到从库，从库中的 I/O 线程将其写到 relay log 中，会有一个 SQL 线程不断读取 relay log 中的内容并解析成具体操作，同步数据。

### 复制方式

效率和可用之间做选择。

- 异步复制

  主库执行完事务后，会立刻返回给客户端，并不关心从库是否同步数据。
  
  问题：
  当主库出现故障时，主库虽然执行完事务了，但是可能还没来得及同步数据给从库就挂了，此时从库升级为主库后，就会丢失掉这次事务的变更数据。
  
- 同步复制

  主库执行完一个事务之后，等所有从库同步数据后，才会返回给客户端。
  
  问题：
  虽然保障了安全性，但是性能很差，因为从库较多会延长整个同步过程。
  
- 半同步复制

  介于异步复制和同步复制之间的一种方案。执行完一个事务后，不会立刻返回给客户端，也不会等所有从库同步完数据，而是等其中几个从库完成同步后，再返回给客户端。
  这样的话性能就比较好，而且数据可靠性也增强了，只有当主库和从库同时都挂了，才会缺失数据。
  
### 主从延迟

主从同步过程中，主服务器（Master）上的数据与从服务器（Slave）上的数据之间存在延迟。
如：一个用户刚注册，然后登陆该用户却不存在的，因为写数据是走主库的，查数据是走从库的，此时数据已经存在主库中，然而从库还未来的及同步，导致查不到这个用户。


- 关键业务读写都走主库，非关键读写分离

- 优化网络

  主节点和从节点尽量部署在同城或者同单元，确保网络连接稳定，减小网络延迟。
  
- 提高从服务器性能

  提高从服务器的硬件配置，如CPU、内存和磁盘
  
- 并行复制

  从库利用 MySQL 提供的并行复制，提升复制的效率，降低延迟。
  
