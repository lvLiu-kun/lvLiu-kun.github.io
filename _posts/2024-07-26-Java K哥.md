# K哥

## 什么是多态？

接口有不同的实现类，这就是多态的表现，多态允许对象在不同的上下文中以不同的方式存在，利于扩展和维护。比如：编写方法的参数时，不关心具体是哪个对象，具体对象由调用方传入，方法我们只要调用 API。

参考资料：
ChatGPT：
https://chatgpt.com/c/e91aac42-07a4-48ce-a61b-24be025e804c

## 什么是泛型？

编写代码的时候不指定具体类型，而是定义一个泛型，进而可以重用代码，由调用者使用的时候去指定具体类型。
比如我们可以用 List 存自己想要的类型元素，就是因为有泛型，如果没泛型，用 add(E e) 方法举例，编写代码时如果把泛型 E 直接换成具体类型，就限制死了，那调用者使用 List 时就只能存指定类型的元素了。

为什么不用 Object 替换泛型？拿 ArrayList<String> 举例，获取元素是需要手动转换类型，而且如果存的值不是转换的类型，就会报错。

### 泛型中的类型参数

E（Element）；
T（Type）；
K（Key）；
V（Value）；
N（Number）；
？（ Wildcard ）：通配符（未知类型）。

参考资料：
ChatGPT：
https://chatgpt.com/c/7dc7105e-fd60-4e7b-a71a-b854ed10d24e

### 泛型约束

 extends、super 等关键字等约束上下限：
<? extends T>：表示 T 类型或者其子类型；
<? super T>：表示 T 类型或者其父类型。

### 泛型擦除

为什么要泛型擦除？为了兼容旧版本，因为 Java 5 之前并没有泛型，如果尝试将一个使用泛型的类传递给一个不使用泛型的类，就会出现异常，反之亦然。
注：泛型只在编译时生效，在运行时失效，泛型擦除将泛型类型替换为它的非泛型上限类型（如果没有指定上限，则替换为 Object），例如，List<String> 和 List<Integer> 在编译后都会变为 List。

扩展：泛型擦除的影响？
类型检查问题：由于泛型擦除，类型检查只会在编译时进行，运行时不会类型检查，如果错误的插入了不兼容的类型，会报 ClassCastException；
方法重载问题：由于泛型参数在运行时被擦除，如果两个泛型方法仅在参数类型上有差异，会认为它们是同一个方法；
无法使用基本数据类型，只能是引用类型；
由于泛型参数在运行时被擦除，反射在运行时无法直接获取或处理泛型的实际类型参数，例如，使用 Field 类获取泛型字段的类型时，得到的类型是 Object 而不是具体的泛型类型。

